#!/usr/bin/env python3

import os
import re
import sys
import tempfile
import argparse
from pprint import pprint

class ReGit:
    def __init__(self):
        self._start()

    def _start(self):
        res = self.parser.parse_known_args()
        if res is None:
            return self.git.execvp()
        self.args, extras = res
        command = self.args.command
        if not isinstance(command, str) or command.startswith('_'):
            return self.help()
        if command in dir(ReGit):
            return getattr(self, command)()
        self.git.execvp()

    def help(self):
        self.parser.print_help()

    def self(self):
        return self.git.pull(os.path.dirname(__file__))

    def up(self):
        err_pull = self.git.do('pull --rebase')
        err_deps = self.deps()
        return err_pull if err_pull else err_deps

    def deps(self):
        result = 0
        for path in self.config.repos:
            if not os.path.exists(path):
                result = self.git.clone('', path)
            else:
                result = self.repeat.up(path)
        return result

    def clone(self):
        return self.cloner.clone(self.args.repo, self.args.path)

    def _getProp(self, name, klass):
        if not hasattr(self, name):
            setattr(self, name, klass(self))
        return getattr(self, name)

    @property
    def aux(self): return self._getProp('_aux', Aux)
    @property
    def git(self): return self._getProp('_git', Git)
    @property
    def config(self): return self._getProp('_config', Config)
    @property
    def cloner(self): return self._getProp('_cloner', Cloner)
    @property
    def parser(self): return self._getProp('_parser', ArgParser)
    @property
    def repeat(self): return self._getProp('_repeat', Repeat)

class Component:
    def __init__(self, regit):
        self.regit = regit

    @property
    def aux(self): return self.regit.aux
    @property
    def git(self): return self.regit.git
    @property
    def config(self): return self.regit.config
    @property
    def repeat(self): return self.regit.repeat

class Repeat(Component):
    def up(self, path):
        return self.do('up', path)

    def deps(self, path):
        return self.do('deps', path)

    def do(self, command, path):
        if not path:
            self.aux.die('path not given for up_in_dir')
        if path == '.':
            return self.aux.do_regit(command)
        cwd = os.getcwd()
        os.chdir(path)
        self.aux.warning(os.getcwd())
        result = self.aux.do_regit(command)
        os.chdir(cwd)
        return result

class Cloner(Component):
    def clone(self, repo, path):
        if path == '.':
            result = self.clone2dot(repo)
        else:
            result = self.git.clone(repo, path)
        if result:
            return result
        return self.repeat.deps(path if path else self.config.repo2path(repo))

    def clone2dot(self, repo):
        if os.path.exists('.git'):
            self.aux.die('git repository already exists in ' + os.getcwd())

        cwd = os.getcwd()
        tmp = tempfile.mkdtemp()
        rep = tempfile.mkdtemp()

        self.aux.system('find {cwd} -mindepth 1 -maxdepth 1 -exec mv -t {tmp} -- {{}} +'.format(cwd=cwd, tmp=tmp))
        try:
            result = self.git.clone(repo, rep)
        except Exception:
            result = 'failed'

        self.rsync_move(rep, cwd)
        self.aux.system('rm -rf {rep}'.format(rep=rep))
        if self.rsync_move(tmp, cwd):
            self.aux.warning('there was error so original dir has been kept in ' + tmp)
        else:
            self.aux.system('rm -rf {tmp}'.format(tmp=tmp))
        return result

class Config(Component):
    def __init__(self, regit):
        Component.__init__(self, regit)
        self.repos = {}
        self.knownRepos = {}
        self.knownSources = {}
        self.load()

    def load(self):
        self.load_global('~/.config/regit/config')
        self.load_local('.regit')

    def load_global(self, path):
        path = os.path.expanduser(path)
        if os.path.exists(path):
            data = self.read_file(path)
            if 'known-repos' in data:
                self.knownRepos.update(data['known-repos'])
            if 'known-sources' in data:
                self.knownSources.update(data['known-sources'])
            if 'includes' in data:
                for name,file in data['includes'].items():
                    self.load_global(file)


    def load_local(self, path):
        if os.path.exists(path):
            data = self.read_file(path)
            if 'repos' in data:
                self.repos.update(data['repos'])

    def read_file(self, path):
        with open(path) as file:
            lines = file.readlines()
        section = ''
        result = {}
        for line in lines:
            line = line.strip()
            check = re.search('^\[(.+)\]$', line)
            if check:
                section = check.group(1)
                if not section in result:
                    result[section] = {}
                continue
            check = re.search('^\s*(\S+)\s*=\s*(.+)\s*$', line)
            if check:
                result[section][check.group(1)] = check.group(2)
                continue
            result[section][line] = line
        return result

    def repo2path(self, repo):
        url = self.path2repo_or_die(repo)
        return os.path.basename(url)

    def path2repo_or_die(self, path):
        repo = self.repath2repo(path)
        if repo:
            return repo
        parts = path.split(os.path.sep)
        if len(parts)<2:
            path = os.path.basename(os.getcwd()) + '/' + path
        return self.config.defaultSource + path

    def repath2repo(self, path):
        repo = self.source2repo(path)
        if not repo:
            repo = self.path2repo(path)
        if repo == path:
            return repo
        return self.repath2repo(repo)

    def path2repo(self, path):
        repo = self.source2repo(path)
        if repo:
            return repo
        if self.is_repo_url(path):
            return path
        repo = self.repos.get(path)
        if repo and repo != path:
            return repo
        if not path in self.knownRepos:
            parts = path.split(os.path.sep)
            if len(parts)<2:
                return ''
            parts.pop(0)
            return self.path2repo(os.path.sep.join(parts))
        return self.knownRepos[path]

    def source2repo(self, path):
        check = self.is_repo_with_source(path)
        if check is None:
            return False
        source = check.group(1)
        if not source in self.knownSources:
            return False
        return self.knownSources[source] + check.group(2)

    def is_repo_with_source(self, path):
        return re.match('^([\w.-]+):([\w.-]+/?[\w.-]*)$', path)

    def is_repo_url(self, repo):
        return ':' in repo or '@' in repo

    @property
    def defaultSource(self):
        return list(self.knownSources.values())[0]

class Git(Component):
    def do(self, command):
        return self.aux.system('git ' + command)

    def clone(self, repo, path):
        repo = self.config.path2repo_or_die(repo if repo else path)
        return self.do('clone {} {}'.format(repo, path))

    def pull(self, path):
        return self.do('-C {} pull --rebase'.format(path))

    def execvp(self):
        args = sys.argv
        args[0] = 'git'
        os.execvp('git', args)

class Aux(Component):
    def do_regit(self, command):
        return self.system(__file__ + ' ' + command)

    def rsync_move(self, src, dst):
        return self.system('rsync -a --remove-source-files {src}/ {dst}/'.format(src=src, dst=dst))

    def system(self, command):
        self.notice('> ' + command.rstrip())
        result = os.system(command)
        if result:
            self.error('! failed')
        return result

    def die(self, text='die', color='error'):
        self.error(text)
        raise Exception(text)

    def error(self, text, color='error'):
        print(self.colored(text, color))

    def warning(self, text, color='warning'):
        print(self.colored(text, color))

    def notice(self, text, color='notice'):
        print(self.colored(text, color))

    def which(self, binary):
        return backtick('which ' + binary)

    def backtick(self, command):
        return os.popen(command).read().strip()

    def tprint(self, text):
        if sys.stdout.isatty():
            print(text, end='')

    def colored(self, text, color, apply = None):
        if apply is None:
            apply = sys.stdout.isatty()
        if not apply:
            return text
        types = {
            'notice':   'white',
            'success':  'green',
            'warning':  'yellow',
            'error':    'red',
        }
        colors = {
            'normal':   '',
            'white':    '\033[97m',
            'cyan':     '\033[96m',
            'magenta':  '\033[95m',
            'blue':     '\033[94m',
            'yellow':   '\033[93m',
            'green':    '\033[92m',
            'red':      '\033[91m',
            'end':      '\033[0m',
        }
        if color in types:
            color = types[color]
        return colors[color] + text + colors['end']

class ArgParser(Component):
    def __init__(self, regit):
        self.regit = regit
        self.parser = MyArgumentParser(description="Repeated Git version 0.0.1")
        self.add_base()
        self.add_clone()
        self.add_scan()
        self.add_deps()
        self.add_up()

    def add_base(self):
        self.parser.add_argument('-f', '--force',   action='store_const', dest='force',   const=True,   default=False, help='force')
        self.parser.add_argument('-v', '--verbose', action='store_const', dest='verbose', const='',     default=False, help='be verbose')
        self.parser.add_argument('-C', '--start-path', nargs=1, help='start at given directory')
        self.parser.add_argument('-V', '--version', action='version', version='%(prog)s 0.0.1')
        self.subparsers = self.parser.add_subparsers(dest='command', help='sub-command name')

    def add_clone(self):
        parser = self.subparsers.add_parser('clone', help='clone a repository into a new directory')
        parser.add_argument('repo', nargs=None, action='store', type=str, default='', help='repository url or name')
        parser.add_argument('path', nargs='?',  action='store', type=str, default='', help='path to clone to')

    def add_scan(self):
        parser = self.subparsers.add_parser('scan', help='recursively scan dirs for repos requiring attention')
        parser.add_argument('path', nargs='?', action='store', type=str, default=os.getcwd(), help='directory to start from')
        parser.add_argument('-p', '--pull', action='store_const', dest='pull', const='pull', default='fetch', help='pull instead of fetch')

    def add_deps(self):
        parser = self.subparsers.add_parser('deps', help='update dependencies')

    def add_up(self):
        parser = self.subparsers.add_parser('up', help='update current repo and dependencies')

    def parse_known_args(self):
        return self.parser.parse_known_args()

    def print_help(self):
        return self.parser.print_help()

class MyArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        pass

if __name__ == '__main__':
    ReGit()
