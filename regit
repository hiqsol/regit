#!/usr/bin/env python3

import os
import re
import sys
import tempfile
import argparse
from pprint import pprint

class ReGit:
    def __init__(self):
        self.parser = self.initParser()
        self.repos = {}
        self.knownRepos = {}
        self.aux = Aux()

    def help(self):
        self.parser.print_help()

    def up(self):
        err_pull = self.git('pull --rebase')
        err_deps = self.deps()
        return err_pull if err_pull else err_deps

    def deps(self):
        result = 0
        for path in self.repos:
            if not os.path.exists(path):
                result = self.vcs_clone('', path)
            else:
                result = self.up_in_dir(path)
        return result

    def up_in_dir(self, path):
        return self.do_in_dir('up', path)
    def deps_in_dir(self, path):
        return self.do_in_dir('deps', path)

    def do_in_dir(self, command, path):
        if not path:
            self.aux.die('path not given for up_in_dir')
        if path == '.':
            return self.regit(command)
        cwd = os.getcwd()
        os.chdir(path)
        self.aux.warning(os.getcwd())
        result = self.regit(command)
        os.chdir(cwd)
        return result

    def clone(self):
        repo = self.args.arg1
        path = self.args.arg2
        if path == '.':
            result = self.clone2dot(repo)
        else:
            result = self.vcs_clone(repo, path)
        if result:
            self.aux.error('! failed')
        return self.deps_in_dir(path if path else self.repo2path(repo))

    def repo2path(self, repo):
        path = self.path2repo(repo)
        self.aux.warning(repo)
        self.aux.die(path)

    def clone2dot(self, repo):
        if os.path.exists('.git'):
            self.aux.die('git repository already exists in ' + os.getcwd())

        cwd = os.getcwd()
        tmp = tempfile.mkdtemp()

        self.aux.system('find {cwd} -mindepth 1 -maxdepth 1 -exec mv -t {tmp} -- {{}} +'.format(cwd=cwd, tmp=tmp))
        try:
            err_clone = self.vcs_clone(repo, cwd)
        except Exception:
            err_clone = 'failed'

        err_rsync = self.aux.system('rsync -a --remove-source-files {tmp}/ {cwd}/'.format(tmp=tmp, cwd=cwd))
        if not err_clone and not err_rsync:
            self.aux.system('rm -rf {tmp}'.format(tmp=tmp))
        else:
            self.aux.warning('there were errors so tmp dir has been kept in ' + tmp)
        return err_clone

    def vcs_clone(self, repo, path):
        zpath = repo if repo else path
        zrepo = self.path2repo(zpath)
        if not zrepo:
            self.aux.die("don't know repo for " + zpath)
        return self.git('clone {} {}'.format(zrepo, path))

    def path2repo(self, path):
        if self.is_repo_url(path):
            return path
        repo = self.repos.get(path)
        if repo and repo != path:
            return repo
        if not path in self.knownRepos:
            parts = path.split(os.path.sep)
            if len(parts)<2:
                return ''
            parts.pop(0)
            return self.path2repo(os.path.sep.join(parts))
        return self.knownRepos[path]

    def is_repo_url(self, repo):
        return ':' in repo or '@' in repo

    def vcs_pull(self, path):
        if os.path.exists(path):
            return system('git -C {} pull --rebase'.format(path))
        else:
            return vcs_clone(repo, path)

    def load_config(self):
        lpath = '.regit'
        gpath = os.path.expanduser('~/.config/regit/config')
        if os.path.exists(lpath):
            local = self.aux.read_config_file(lpath)
            if 'repos' in local:
                self.repos = local['repos']
        if os.path.exists(gpath):
            globe = self.aux.read_config_file(gpath)
            if 'known-repos' in globe:
                self.knownRepos = globe['known-repos']

    def run(self):
        args, unknown = self.parser.parse_known_args()
        if args.command in dir(ReGit):
            self.args = args
            self.load_config()
            getattr(self, args.command)()
        else:
            args = sys.argv
            args[0] = 'git'
            os.execvp('git', args)

    def initParser(self):
        parser = argparse.ArgumentParser(description="Repeated Git version 0.0.1")
        parser.add_argument('-f', '--force',   action='store_const', dest='force',   const=True,   default=False,      help='force')
        parser.add_argument('-v', '--verbose', action='store_const', dest='verbose', const='',     default=' --quiet', help='be verbose')
        parser.add_argument('-V', '--version', action='version', version='%(prog)s 0.0.1')
        parser.add_argument('command', nargs='?', action='store', type=str, default='help', help='command name')
        parser.add_argument('arg1', nargs='?', action='store', type=str, default='')
        parser.add_argument('arg2', nargs='?', action='store', type=str, default='')
        return parser

    def regit(self, command):
        return self.aux.system(__file__ + ' ' + command)
    def git(self, command):
        return self.aux.system('git ' + command)

class Aux:
    def system(self, command):
        self.notice('> ' + command.rstrip())
        result = os.system(command)
        if result:
            self.error('! failed')
        return result

    def read_config_file(self, path):
        with open(path) as file:
            lines = file.readlines()
        self.repos = {}
        section = ''
        result = {}
        for line in lines:
            line = line.strip()
            check = re.search('^\[(.+)\]$', line)
            if check:
                section = check.group(1)
                if not section in result:
                    result[section] = {}
                continue
            check = re.search('^\s*(\S+)\s*=\s*(.+)\s*$', line)
            if check:
                result[section][check.group(1)] = check.group(2)
                continue
            result[section][line] = line
        return result

    def die(self, text='die', color='error'):
        self.error(text)
        raise Exception(text)

    def error(self, text, color='error'):
        print(self.colored(text, color))

    def warning(self, text, color='warning'):
        print(self.colored(text, color))

    def notice(self, text, color='notice'):
        print(self.colored(text, color))

    def which(self, binary):
        return backtick('which ' + binary)

    def backtick(self, command):
        return os.popen(command).read().strip()

    def colored(self, text, color):
        types = {
            'notice':   'white',
            'success':  'green',
            'warning':  'yellow',
            'error':    'red',
        }
        colors = {
            'normal':   '',
            'white':    '\033[97m',
            'cyan':     '\033[96m',
            'magenta':  '\033[95m',
            'blue':     '\033[94m',
            'yellow':   '\033[93m',
            'green':    '\033[92m',
            'red':      '\033[91m',
            'end':      '\033[0m',
        }
        if color in types:
            color = types[color]
        return colors[color] + text + colors['end']

if __name__ == '__main__':
    ReGit().run()
